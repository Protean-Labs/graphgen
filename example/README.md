# Uniswap V2 Example
This directory contains an example of a subgraph generated by graphgen based on an annotated version of Uniswap V2's interface files. Uniswap V2's contracts, some of the most forked contracts in DeFi, make a good case study to demonstrate the functioning of GraphGen. We will go through each annotation and explain what it generates and where. 

The annotated interfaces can be found in `IUniswapV2.sol` and all the generated code can be found in the `subgraph/` directory (note that this directory only contains what GraphGen generates, i.e.: before running `graph codegen`).

## IUniswapV2Pair

### **@gg:source**
```solidity
/* @gg:source
  name: Pair
*/
interface IUniswapV2Pair {
  ...
}
```

The `@gg:source` annotation added to the `IUniswapV2Pair` interface definition indicates to GraphGen that contracts with this interface are a source of data in our subgraph. More specifically, since no `instances` field is provided in the annotation, GraphGen infers that these contracts in particular are subgraph templates.

Since the `name` field of the annotation is present and set to `Pair`, GraphGen will use this name to refer to both the subgraph entities and contracts implementing this interface.

**subgraph.yaml**

Based on this annotation, the following will be generated in the subgraph manifest:
```yaml
templates:
  - kind: ethereum/contract
    name: Pair
    network: mainnet
    source:
      abi: Pair
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.3
      language: wasm/assemblyscript
      file: ./src/mappings/Pair.ts
      ...
      abis:
        - name: Pair
          file: ./abis/Pair.json
        ...
      eventHandlers:
        ...
```
Notice the use of `Pair` instead of `IUniswapV2Pair`.

Note: The `...` is used throughout this example to indicate that other things are generated, but not by this particular annotation in question (i.e.: `@gg:source`).

**schema.graphql**

From this `@gg:source` annotation, a `Pair` entity is also created in the schema:
```graphql
type Pair @entity {
  id: ID!   # CONTRACT_ADDR

  ...
}
```

**src/mappings/Pair.ts**
After simply defining the Pair interface as a `@gg:source`, the following functions are generated to create the entity. Note: Ignore the `parent: FactoryEntity` argument for now, we'll come back to this when we get to the `Factory` interface.

```typescript
import {
  Pair as PairEntity,
  ...
} from '../types/schema'

import {
  Address,
  ...
} from '@graphprotocol/graph-ts'

...

function createPairEntity(parent: FactoryEntity, address: Address): PairEntity {
  let entity = new PairEntity(address.toHexString())

  ...

  entity.save()
  return entity
}

export function getCreatePairEntity(parent: FactoryEntity, address: Address): PairEntity {
  let entity = PairEntity.load(address.toHexString())
  if (entity == null) {
    entity = createPairEntity(parent, address)
  }
  return entity as PairEntity
}
```

**abis/Pair.json**
The `Pair` ABI file is also generated according to standard specifications (nothing fancy here).

### **@gg:field**
```solidity
/* @gg:source
  name: Pair
*/
interface IUniswapV2Pair {
  /* @gg:field */
  function name() external pure returns (string memory);
  
  /* @gg:field */
  function symbol() external pure returns (string memory);
  
  /* @gg:field */
  function decimals() external pure returns (uint8);
  
  /* @gg:field */
  function totalSupply() external view returns (uint);

  ...

  /* @gg:field */
  function token0() external view returns (address);
  
  /* @gg:field */
  function token1() external view returns (address);
  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

  /* @gg:field 
    name: price0 */
  function price0CumulativeLast() external view returns (uint);
  
  /* @gg:field 
    name: price1 */
  function price1CumulativeLast() external view returns (uint);
}
```

The `@gg:field` annotations are used to explicitly define attributes associated with the entity bound to the interface. As mentioned in the documentation section of the repo's README.md, `@gg:field` annotations can only be used with functions that do not mutate state (i.e.: `pure` or `view` functions). This is because these functions take on the role of "getter" functions for the defined fields.

**schema.graphql**
```graphql
type Pair @entity {
  id: ID!   # CONTRACT_ADDR
  
  price1: BigInt!
  price0: BigInt!
  token1: Bytes!
  token0: Bytes!
  totalSupply: BigInt!
  decimals: BigInt!
  symbol: String!
  name: String!

  ...
}
```

Each field defined with annotations in the interface files generates a corresponding entity attribute in the schema.

**src/mappings/Pair.ts**
```typescript
import { Pair as PairContract } from '../types/templates/Pair/Pair'

import {
  Pair as PairEntity,
  ...
} from '../types/schema'

import {
  Address,
  ...
} from '@graphprotocol/graph-ts'

...

function createPairEntity(parent: FactoryEntity, address: Address): PairEntity {
  let entity = new PairEntity(address.toHexString())

  let contract = PairContract.bind(address)
  entity.price1 = contract.price1CumulativeLast()
  entity.price0 = contract.price0CumulativeLast()
  entity.token1 = contract.token1()
  entity.token0 = contract.token0()
  entity.totalSupply = contract.totalSupply()
  entity.decimals = contract.decimals()
  entity.symbol = contract.symbol()
  entity.name = contract.name()
  ...

  entity.save()
  return entity
}

...
```

The fields defined with `@gg:field` annotations are also initialized by calling their respective "getter" functions when the `Pair` entity is created.

### **@gg:handler**
```solidity
/* @gg:source
  name: Pair
*/
interface IUniswapV2Pair {
  /* @gg:handler 
      actions:
        - StoreEvent
        - UpdateField totalSupply
    */
  event Mint(address indexed sender, uint amount0, uint amount1);

  /* @gg:handler 
      actions:
        - StoreEvent
        - UpdateField totalSupply
    */
  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);

  /* @gg:handler 
      actions:
        - StoreEvent
        - UpdateField price0
        - UpdateField price1
    */
  event Swap(
      address indexed sender,
      uint amount0In,
      uint amount1In,
      uint amount0Out,
      uint amount1Out,
      address indexed to
  );

  ...

  /* @gg:field */
  function token0() external view returns (address);
  
  /* @gg:field */
  function token1() external view returns (address);

  /* @gg:field 
    name: price0 */
  function price0CumulativeLast() external view returns (uint);
  
  /* @gg:field 
    name: price1 */
  function price1CumulativeLast() external view returns (uint);
}
```

`@gg:handler` annotations are where most of the magic happens. The Uniswap V2 example defines three handlers for the `Mint`, `Burn` and `Swap` events, as well as the actions that must be taken when each handler is triggered.

**subgraph.yaml**
```yaml
templates:
  - kind: ethereum/contract
    name: Pair
    network: mainnet
    source:
      abi: Pair
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.3
      language: wasm/assemblyscript
      file: ./src/mappings/Pair.ts
      entities:
        - Swap
        - Burn
        - Mint
        ...
      abis:
        - name: Pair
          file: ./abis/Pair.json
          ...
      eventHandlers:
        - event: Swap(indexed address,uint256,uint256,uint256,uint256,indexed address)
          handler: handleSwap
        - event: Burn(indexed address,uint256,uint256,indexed address)
          handler: handleBurn
        - event: Mint(indexed address,uint256,uint256)
          handler: handleMint
```
Each `@gg:handler` annotation (unsurpsisingly) generates a corresponding entry in the `eventHandlers` list. The entities bound to each event (see below) are also added to the `entities` list.

**schema.graphql**
```
type Transaction @entity {
  id: ID!   # tx hash
  txIndex: Int!
  from: Bytes!
  to: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  events: [Event!]! @derivedFrom(field: "tx") 
  
}

interface Event {
  id: ID!   # CONTRACT_ADDR-PER_EVENT_COUNTER
  logIndex: BigInt!
  tx: Transaction!
}

type Pair @entity {
  id: ID!   # CONTRACT_ADDR

  ...  

  numSwaps: BigInt!
  latestSwap: Swap
  swaps: [Swap!]! @derivedFrom(field: "pair")
  numBurns: BigInt!
  latestBurn: Burn
  burns: [Burn!]! @derivedFrom(field: "pair")
  numMints: BigInt!
  latestMint: Mint
  mints: [Mint!]! @derivedFrom(field: "pair")  

  ...
}

type Swap implements Event @entity {
  id: ID!   # CONTRACT_ADDR-PER_EVENT_COUNTER
  logIndex: BigInt!
  tx: Transaction!

  # Event params
  sender: Bytes!
  amount0In: BigInt!
  amount1In: BigInt!
  amount0Out: BigInt!
  amount1Out: BigInt!
  to: Bytes!

  pair: Pair!
}
```

Since each `@gg:handler` defined in the annotated interface file includes a `StoreEvent` action, each of the three aforementioned events will be stored in the subgraph with their own entities (only the `Swap` entity is shown above, but the same applies to the other two events). Event entities contain all parameters contained in the actual events, as well as a reference to the entity that emitted them (in this case, the `pair` attribute).

Moreover, the emitter entity (in this case the `Pair` entity) contains a few new fields for each event that it emits that is also stored. In this case, these would be the `latest[Event]` and `num[Event]s` fields. These make it easy to extract information from the generated subgraphs.

The `Event` entity is a built-in entity generated by GraphGen if events are stored in the subgraph. Likewise, the `Transaction` entity is a built-in entity generated by GraphGen whenever either events or calls are stored in the subgraph.

**src/mappings/Pair.ts**

```typescript
import {
  Pair as PairEntity,
  Swap as SwapEntity,
  Burn as BurnEntity,
  Mint as MintEntity,
  Factory as FactoryEntity,
} from '../types/schema'



import {
  Swap as SwapEvent,
  Burn as BurnEvent,
  Mint as MintEvent,
} from '../types/templates/Pair/Pair'

function createPairEntity(parent: FactoryEntity, address: Address): PairEntity {
  let entity = new PairEntity(address.toHexString())

  let contract = PairContract.bind(address)
  entity.price1 = contract.price1CumulativeLast()
  entity.price0 = contract.price0CumulativeLast()
  entity.token1 = contract.token1()
  entity.token0 = contract.token0()
  entity.totalSupply = contract.totalSupply()
  entity.decimals = contract.decimals()
  entity.symbol = contract.symbol()
  entity.name = contract.name()

  
  entity.numSwaps = BigIntZero
  entity.numBurns = BigIntZero
  entity.numMints = BigIntZero

  ...

  entity.save()
  return entity
}

...

function createSwapEntity(source: PairEntity, event: SwapEvent): SwapEntity {
  let eventEntity = new SwapEntity(source.id + "-" + source.numSwaps.toString())
  eventEntity.sender = event.params.sender
  eventEntity.amount0In = event.params.amount0In
  eventEntity.amount1In = event.params.amount1In
  eventEntity.amount0Out = event.params.amount0Out
  eventEntity.amount1Out = event.params.amount1Out
  eventEntity.to = event.params.to
  
  eventEntity.pair = source.id
  eventEntity.save()
  return eventEntity
}

export function handleSwap(event: SwapEvent): void {
  // TODO: Add some checks here
  let source = PairEntity.load(event.address.toHexString()) as PairEntity

  // Create and store event entity
  let eventEntity = createSwapEntity(source, event)
  source.numSwaps = source.numSwaps + BigIntOne
  source.latestSwap = eventEntity.id

  // Update fields
  let contract = PairContract.bind(event.address)
  source.price1 = contract.price1CumulativeLast()
  source.price0 = contract.price0CumulativeLast()

  

  source.save()
}

...

```

We'll focus our attention on the `Swap` event handler, but all that is said also applies to the `Mint` and `Burn` event handlers.

For each event handler, a function named `handle[Event]` will be created, in which most of the handler actions' logic will be found. In our example, since `Swap` events are stored, a function named `createSwapEntity` is generated to handle the entity creation process.

In the actual handler function, one can see that some entity fields being updated (as defined by the `UpdateField` actions of the handler). These field must have been defined using a `@gg:field` annotation otherwise GraphGen will throw an error.

Moreover, one will notice that the emitter's fields related to the event (`numSwaps` and `latestSwap`) are also being updated as well as initialized in the `createPairEntity` function.

## IUniswapV2Factory
Most of what was said about the `IUniswapV2Pair` interface and its annotations also apply to the `IUniswapV2Factory` interface. We'll therefore focus on what is different or new.

### **@gg:source**
```solidity
/* @gg:source
  name: Factory
  instances:
    - address: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f'
      startBlock: 10000834
*/
interface IUniswapV2Factory {
  ...
}
```

**subgraph.yaml**
```yaml
dataSources:  
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f'
      abi: Factory
      startBlock: 10000834
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.3
      language: wasm/assemblyscript
      file: ./src/mappings/Factory.ts
      entities:
        - Factory
        ...
      abis:
        - name: Factory
          file: ./abis/Factory.json
          ...
      eventHandlers:
          ...
```

The main difference here between the `IUniswapV2Pair` interface and the `IUniswapV2Factory` interface is that the latter has `instances`. GraphGen infers from this that the contract implementing the interface must therefore be a `dataSource`.

**src/mappings/Factory.ts**
```typescript
function createFactoryEntity(address: Address): FactoryEntity {
  let entity = new FactoryEntity(address.toHexString())

  ...
  
  entity.numPairs = BigIntZero

  entity.save()
  return entity
}

export function getCreateFactoryEntity(address: Address): FactoryEntity {
  let entity = FactoryEntity.load(address.toHexString())
  if (entity == null) {
    entity = createFactoryEntity(address)
  }
  return entity as FactoryEntity
}
```

The main difference between these two create functions and those of the `Pair` entity are that these ones do not take a `parent` argument (see below).

### **@gg:handler**
```solidity
interface IUniswapV2Factory {
  /* @gg:handler 
    actions:
      - NewEntity Pair from pair
  */
  event PairCreated(address indexed token0, address indexed token1, address pair, uint);

  ...
}
```

The one new handler action present in the `Factory` annotations is the `NewEntity` action. In our example, this tells GraphGen that `Pair` entities, which are contracts that implement the `IUniswapV2Pair` interface, should be generated when `PairCreated` events are emitted with the `pair` field of the event used as both the address and the id of the newly created entity. In this case, the `Factory` entity would be considered the `parent` of the relationship and `Pair` entity, the `child`. 

Note on `parent`/`children`: These terms refer only to the way by which entities are added to the subgraph and not to their logical of time precedence. For example, if `ERC20` entities were also created in the subgraph everytime a pair is created (for `token0` and `token1`), then the `ERC20` entity would be considered a child entity of the `Factory` entity even though they clearly predate the Uniswap V2 Factory contract. Moreover, it is possible for a single entity to be both a `parent` and `child`. 

**schema.graphql**
```graphql
type Factory @entity {
  id: ID!   # CONTRACT_ADDR

  ...

  numPairs: BigInt!
  latestPair: Pair
  pairs: [Pair!]! @derivedFrom(field: "factory")
}

type Pair @entity {
  id: ID!   # CONTRACT_ADDR
  
  ...

  factory: Factory!
}
```

The `NewEntity` handler action is what connects the `Factory` entity to the `Pair` entities in the subgraph by adding edges between them. Just like with events, all `parent` entities have two fields related to their children, in our case `numPairs` and `latestPair`.

**src/mappings/Factory.ts**
```typescript

export function handlePairCreated(event: PairCreatedEvent): void {
  let source = getCreateFactoryEntity(event.address)

  ...

  // Create entities and templates
  let pair = getCreatePairEntity(source, event.params.pair)
  source.numPairs = source.numPairs + BigIntOne
  source.latestPair = pair.id
  PairContract.create(event.params.pair)
  
  source.save()
}
```

**src/mappings/Pair.ts**
```typescript
function createPairEntity(parent: FactoryEntity, address: Address): PairEntity {
  let entity = new PairEntity(address.toHexString())

  ...

  entity.factory = parent.id
  entity.save()
  return entity
}

export function getCreatePairEntity(parent: FactoryEntity, address: Address): PairEntity {
  let entity = PairEntity.load(address.toHexString())
  if (entity == null) {
    entity = createPairEntity(parent, address)
  }
  return entity as PairEntity
}
```

We can now finally understand why the `parent: FactoryEntity` argument was part of the creation functions for the `Pair` entities.